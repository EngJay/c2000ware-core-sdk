let Common   = system.getScript("/driverlib/Common.js");
let Pinmux   = system.getScript("/driverlib/pinmux.js");

let PGASignals = system.getScript("/driverlib/pga/pga_inputSignals.js")

let device_driverlib_peripheral =
    system.getScript("/driverlib/device_driverlib_peripherals/" +
        Common.getDeviceName().toLowerCase() + "_pga.js");

//For ADC sample+hold requirements
let device_pga_char =
    system.getScript("/driverlib/pga/pga_char.js");

var device_pga_SH = device_pga_char.SH[Common.getDeviceName()]
 
let device_driverlib_memmap =
    system.getScript("/driverlib/device_driverlib_peripherals/" +
        Common.getDeviceName().toLowerCase() + "_memmap.js");

var PGA_INSTANCE = [];
for (var pga of device_driverlib_memmap.PGAMemoryMap) {
    PGA_INSTANCE.push({
        name : pga.name,
        displayName : pga.displayName
    })
}
 
/* Intro splash on GUI */
let longDescription = "";

var longDescriptionSignalConditionCalculator = `
An approximation of the new PGA input voltage range generated by applying a DC offset voltage and voltage divider to the signal source. This is given by the equation:

![an offline image](../../driverlib/.meta/pga/docs/offset_equation.png)

Block diagram/Pins:

![an offline image](../../driverlib/.meta/pga/docs/offset_diagram.png)

Where the following parameters are dependent on the application design:
*   SIGNAL = Input signal voltage (specify minimum/maximum of possible voltage range)
*	R1 = Resistance connected in series with SIGNAL; parallel to R2
*   R2 = Resistance connected in series with V_DCSOURCE; parallel to R1
*   V_DCSOURCE = DC Source output voltage
*   PGA_IN = Input applied to PGA (with new minimum/maximum voltage range)
`

var longDescriptionCutoffFreqCalculator = `
An approximation of the cutoff frequency resulting from the low-pass RC filter applied on the PGA output signal. This is given by the equation:

![an offline image](../../driverlib/.meta/pga/docs/cutoff_freq_equation.png)

Block diagram/Pins:

![an offline image](../../driverlib/.meta/pga/docs/cutoff_freq_diagram.png)

Where the following parameters are dependent on the application design:
*	Rfilter = Filter resistance configured internally by the PGA (in Ohms)
*	Cfilter = Filter capacitance applied externally to PGA_OF (in pF)
`

function onChangeEnableFilter(inst, ui)
{
    if (inst.enableFilter == true){
        ui.filterMode.hidden = false
        ui.PGA_OFPinInfo.hidden = false
        ui.useCutoffFreqCalculator.hidden = false
    }
    else {
        ui.filterMode.hidden = true
        ui.PGA_OFPinInfo.hidden = true
        ui.useCutoffFreqCalculator.hidden = true
        ui.filterResistance.hidden = true
        ui.filterCapacitance.hidden = true
        ui.calculatedCutoffFreq.hidden = true
    }   
}

function onChangeUseSignalConditionCalculator(inst, ui)
{
    if (inst.useSignalConditionCalculator == true){
        ui.inputSignalMinVoltage.hidden = false
        ui.inputSignalMaxVoltage.hidden = false
        ui.signalConditionDCSourceVoltage.hidden = false
        ui.signalConditionR1.hidden = false
        ui.signalConditionR2.hidden = false
        ui.signalConditionVDDA.hidden = false
        ui.signalConditionVSSA.hidden = false
        ui.calculatedInputSignalConditionMin.hidden = false
        ui.calculatedInputSignalConditionMax.hidden = false
        ui.calculatedOutputSignalConditionMin.hidden = false
        ui.calculatedOutputSignalConditionMax.hidden = false
    }
    else {
        ui.inputSignalMinVoltage.hidden = true
        ui.inputSignalMaxVoltage.hidden = true
        ui.signalConditionDCSourceVoltage.hidden = true
        ui.signalConditionR1.hidden = true
        ui.signalConditionR2.hidden = true
        ui.signalConditionVDDA.hidden = true
        ui.signalConditionVSSA.hidden = true
        ui.calculatedInputSignalConditionMin.hidden = true
        ui.calculatedInputSignalConditionMax.hidden = true
        ui.calculatedOutputSignalConditionMin.hidden = true
        ui.calculatedOutputSignalConditionMax.hidden = true
    }
}

function onChangeUseCutoffFreqCalculator(inst, ui)
{
    //make rest of calculator visible
    if (inst.useCutoffFreqCalculator == true){
        ui.filterResistance.hidden = false
        ui.filterCapacitance.hidden = false
        ui.filterResistance.hidden = false
        ui.calculatedCutoffFreq.hidden = false
    }
    else {
        ui.filterResistance.hidden = true
        ui.filterCapacitance.hidden = true
        ui.filterResistance.hidden = true
        ui.calculatedCutoffFreq.hidden = true
    }
}

function calculateGainModeNumeric(gainMode) {
    if (gainMode == "PGA_GAIN_3") {
        var tempgainNumber = 3
    }
    if (gainMode == "PGA_GAIN_6") {
        var tempgainNumber = 6
    }
    if (gainMode == "PGA_GAIN_12") {
        var tempgainNumber = 12
    }
    if (gainMode == "PGA_GAIN_24") {
        var tempgainNumber = 24
    }
    return tempgainNumber
}

function calculateFilterModeNumeric(inst, ui)
{
    //map enums to numeric resistance values
    if (inst.filterMode == "PGA_LOW_PASS_FILTER_RESISTOR_200_OHM") {
        var tempfilterNumber = 200
    }
    if (inst.filterMode == "PGA_LOW_PASS_FILTER_RESISTOR_160_OHM") {
        var tempfilterNumber = 160
    }
    if (inst.filterMode == "PGA_LOW_PASS_FILTER_RESISTOR_130_OHM") {
        var tempfilterNumber = 130
    }
    if (inst.filterMode == "PGA_LOW_PASS_FILTER_RESISTOR_100_OHM") {
        var tempfilterNumber = 100
    }
    if (inst.filterMode == "PGA_LOW_PASS_FILTER_RESISTOR_80_OHM") {
        var tempfilterNumber = 80
    }
    if (inst.filterMode == "PGA_LOW_PASS_FILTER_RESISTOR_50_OHM") {
        var tempfilterNumber = 50
    }
    return tempfilterNumber
}

function calculateInputSignalConditionMin(inst, ui)
{
    var signalMin = inst.inputSignalMinVoltage;
    var DCsource = inst.signalConditionDCSourceVoltage;
    var R1 = inst.signalConditionR1;
    var R2 = inst.signalConditionR2;
    var unrounded = (R2*(signalMin-DCsource))/(R1+R2)+DCsource
    return Math.round(unrounded * 1000) / 1000
}

function calculateInputSignalConditionMax(inst, ui)
{
    var signalMax = inst.inputSignalMaxVoltage;
    var DCsource = inst.signalConditionDCSourceVoltage;
    var R1 = inst.signalConditionR1;
    var R2 = inst.signalConditionR2;
    var unrounded = (R2*(signalMax-DCsource))/(R1+R2)+DCsource
    return Math.round(unrounded * 1000) / 1000
}

function calculateOutputSignalConditionMin(inst, ui)
{
    var unrounded = inst.calculatedInputSignalConditionMin * calculateGainModeNumeric(inst.gainMode)
    return Math.round(unrounded * 1000) / 1000
}

function calculateOutputSignalConditionMax(inst, ui)
{
    var unrounded = inst.calculatedInputSignalConditionMax * calculateGainModeNumeric(inst.gainMode)
    return Math.round(unrounded * 1000) / 1000
}

function calculateCutoffFreq(inst, ui)
{
    var Rfilt = inst.filterResistance; //Ohms
    var Cfilt = inst.filterCapacitance; //pF (10^-12)
    var unrounded = 1/(2*Math.PI*Rfilt*Cfilt) * Math.pow(10, 6) //convert THz to MHz (10^12 to 10^6)
    return Math.round(unrounded * 1000) / 1000
}

function calculateDevicePinNameOF(inst, ui)
{
    var tempPinName = inst.pgaBase.substr(0, inst.pgaBase.indexOf('_')) + "_OF"
    var tempPinInfo = Pinmux.findAllAnalogPin(tempPinName);
    var tempPinInfoDesc = Pinmux.getDevicePinInfoDescription(tempPinInfo) 
    return tempPinInfoDesc
}

function calculateDevicePinNameIN(inst, ui)
{
    var tempPinName = inst.pgaBase.substr(0, inst.pgaBase.indexOf('_')) + "_IN"
    var tempPinInfo = Pinmux.findAllAnalogPin(tempPinName);
    var tempPinInfoDesc = Pinmux.getDevicePinInfoDescription(tempPinInfo) 
    return tempPinInfoDesc
}

function calculateDevicePinNameGND(inst, ui)
{
    var tempPinName = inst.pgaBase.substr(0, inst.pgaBase.indexOf('_')) + "_GND"
    var tempPinInfo = Pinmux.findAllAnalogPin(tempPinName);
    var tempPinInfoDesc = Pinmux.getDevicePinInfoDescription(tempPinInfo) 
    return tempPinInfoDesc
}

function calculateDevicePinNameOUT(inst, ui)
{
    var instNum = inst.pgaBase[3]
    var tempPinInfoDesc = PGASignals.PGAInputSignals["PGA_OUT"][instNum-1].displayName
    return tempPinInfoDesc
}

var PGA_OF_PinInfos = Pinmux.findAllAnalogPin("PGA1_OF");
var PGA_IN_PinInfos = Pinmux.findAllAnalogPin("PGA1_IN");
var PGA_GND_PinInfos = Pinmux.findAllAnalogPin("PGA1_GND");
var PGA_OUT_PinInfos = PGASignals.PGAInputSignals["PGA_OUT"][0].displayName

/* Array of PGA configurables that are common across device families */
let config = [
    {
        name        : "pgaBase",
        displayName : "PGA Instance",
        description : 'Instance of the PGA used.',
        hidden      : false,
        default     : PGA_INSTANCE[0].name,
        options     : PGA_INSTANCE
    },

    {
        name        : "pgaEnable",
        displayName : "PGA Enable",
        description : 'Whether or not to enable this PGA instance.',
        hidden      : false,
        default     : false,
    },

    {
        name        : "gainMode",
        displayName : "Gain Value",
        description : 'Gain value applied to input signal.',
        hidden      : false,
        default     : device_driverlib_peripheral.PGA_GainValue[0].name,
        options     : device_driverlib_peripheral.PGA_GainValue
    },

    {
        name        : "lockedRegisters",
        displayName : "Lock PGA Registers",
        description : 'Select PGA Registers to lock.',
        hidden      : false,
        default     : [],
        minSelections: 0,
        options     : device_driverlib_peripheral.PGA_REGISTER
    },
];

config = config.concat([{
    name        : "GROUP_signalConditionCalculator",
    displayName : "Signal Conditioning Calculator",
    longDescription : longDescriptionSignalConditionCalculator,
    config      : [
        {
            name: "useSignalConditionCalculator",
            displayName: "Use Signal Conditioning Calculator",
            hidden: false,
            default: false,
            onChange: onChangeUseSignalConditionCalculator,
        },
        {
            name: "inputSignalMinVoltage",
            displayName: "Input Signal Minimum Voltage (V)",
            hidden: true,
            default: -0.5,
        },
        {
            name: "inputSignalMaxVoltage",
            displayName: "Input Signal Maximum Voltage (V)",
            hidden: true,
            default: 0.5,
        },
        {
            name: "signalConditionDCSourceVoltage",
            displayName: "DC Source Output Voltage (V)",
            hidden: true,
            default: 1.65,
        },
        {
            name: "signalConditionR1",
            displayName: "R1 resistance (Ω)",
            hidden: true,
            default: 10000,
        },
        {
            name: "signalConditionR2",
            displayName: "R2 resistance (Ω)",
            hidden: true,
            default: 20000,
        },
        {
            name: "signalConditionVDDA",
            displayName: "VDDA Voltage (V)",
            hidden: true,
            readOnly: true,
            default: 3.3,
        },
        {
            name: "signalConditionVSSA",
            displayName: "VSSA Voltage (V)",
            hidden: true,
            readOnly: true,
            default: 0,
        },
        {
            name: "calculatedInputSignalConditionMin",
            displayName: "PGA Input Minimum Voltage (V)",
            hidden: true,
            default: 0,
            getValue: calculateInputSignalConditionMin,
        },
        {
            name: "calculatedInputSignalConditionMax",
            displayName: "PGA Input Maximum Voltage (V)",
            hidden: true,
            default: 0,
            getValue: calculateInputSignalConditionMax,
        },
        {
            name: "calculatedOutputSignalConditionMin",
            displayName: "PGA Output Minimum Voltage (V)",
            hidden: true,
            default: 0,
            getValue: calculateOutputSignalConditionMin,
        },
        {
            name: "calculatedOutputSignalConditionMax",
            displayName: "PGA Output Maximum Voltage (V)",
            hidden: true,
            default: 0,
            getValue: calculateOutputSignalConditionMax,
        },
    ]
}]);

config = config.concat([{
    name: "GROUP_FILTERING",
    displayName: "Low-Pass Filtering",
    description: "PGA low-pass filtering configuration",
    longDescription: "",
    config: [
        {
            name        : "enableFilter",
            displayName : "Enable Low-Pass Filtering?",
            description : 'Whether or not to enable low-pass filtering of output signal.',
            hidden      : false,
            onChange    : onChangeEnableFilter,
            default     : false
        },
    
        {
            name        : "filterMode",
            displayName : "Low-Pass Resistor Value",
            description : 'Resistance value for low-pass filtering of output signal.',
            hidden      : true,
            default     : device_driverlib_peripheral.PGA_LowPassResistorValue[1].name,
            options     : device_driverlib_peripheral.PGA_LowPassResistorValue.slice(1)
        },

        {
            name        : "GROUP_cutoffFreqCalculator",
            displayName : "Cutoff Frequency Calculator",
            longDescription : longDescriptionCutoffFreqCalculator,
            config      : [
                {
                    name: "useCutoffFreqCalculator",
                    displayName: "Use Cutoff Frequency Calculator",
                    hidden: true,
                    default: false,
                    onChange: onChangeUseCutoffFreqCalculator,
                },
                {
                    name: "filterResistance",
                    displayName: "Filtering Resistance (Ω)",
                    hidden: true,
                    default: 200,
                    getValue: calculateFilterModeNumeric,
                },
                {
                    name: "filterCapacitance",
                    displayName: "Filtering Capacitance (pF)",
                    hidden: true,
                    default: 10,
                },
                {
                    name: "calculatedCutoffFreq",
                    displayName: "Cutoff Frequency (MHz)",
                    hidden: true,
                    default: 0,
                    getValue: calculateCutoffFreq,
                },
            ]
        },
    ]
}]);

config = config.concat([{
    name: "GROUP_PIN_INFO",
    displayName: "Pin Info",
    description: "PGA Pin Assignment Info",
    longDescription: "",
    config: [
        {
            name        : "PGA_INPinInfo",
            displayName : "Input Pin Info",
            description : 'Pin Number and Name for selected PGA instance.',
            hidden      : false,
            default     : Pinmux.getDevicePinInfoDescription(PGA_IN_PinInfos),
            getValue    : calculateDevicePinNameIN
        },
    
        {
            name        : "PGA_GNDPinInfo",
            displayName : "Ground Pin Info",
            description : 'Pin Number and Name for selected PGA instance.',
            hidden      : false,
            default     : Pinmux.getDevicePinInfoDescription(PGA_GND_PinInfos),
            getValue    : calculateDevicePinNameGND
        },

        {
            name        : "PGA_OUTPinInfo",
            displayName : "Output Pin Info (Internal)",
            description : 'Pin Number and Name for selected PGA instance. This is an internal signal.',
            hidden      : false,
            default     : Pinmux.getDevicePinInfoDescription(PGA_OUT_PinInfos),
            getValue    : calculateDevicePinNameOUT
        },

        {
            name        : "PGA_OFPinInfo",
            displayName : "Filtered Output Pin Info",
            description : 'Pin Number and Name for selected PGA instance.',
            hidden      : true,
            default     : Pinmux.getDevicePinInfoDescription(PGA_OF_PinInfos),
            getValue    : calculateDevicePinNameOF
        },
    ]
}]);
 
function onValidate(inst, validation)
{
    var usedPGAInsts = [];
    for (var instance_index in inst.$module.$instances)
    {
        var instance_obj = inst.$module.$instances[instance_index];
        usedPGAInsts.push(instance_obj.pgaBase);
    }
    
    var duplicatesResult = Common.findDuplicates(usedPGAInsts)
    
    if (duplicatesResult.duplicates.length != 0)
    {
        var allDuplicates = "";
        for (var duplicateNamesIndex in duplicatesResult.duplicates)
        {
            allDuplicates = allDuplicates + Common.stringOrEmpty(allDuplicates, ", ")
                            + duplicatesResult.duplicates[duplicateNamesIndex];
        }
        validation.logError(
            "This PGA Instance is already in use! Duplicates: " + allDuplicates,
            inst, "pgaBase");
    }

    //Signal Conditioning Calculator Conditions
    if (inst.useSignalConditionCalculator) {
        if (inst.inputSignalMinVoltage > inst.inputSignalMaxVoltage) {
            validation.logError("Maximum voltage must be greater than minimum voltage!", inst, "inputSignalMaxVoltage");
        }

        if (inst.inputSignalMinVoltage < -999999 || inst.inputSignalMinVoltage > 999999) {
            validation.logError("Input voltage must not have magnitude greater than 999,999V!", inst, "inputSignalMinVoltage");
        }
    
        if (inst.inputSignalMaxVoltage < -999999 || inst.inputSignalMaxVoltage > 999999) {
            validation.logError("Input voltage must not have magnitude greater than 999,999V!", inst, "inputSignalMaxVoltage");
        }
    
        if (inst.signalConditionDCSourceVoltage > 999999 || inst.signalConditionDCSourceVoltage < -999999) {
            validation.logError("Input voltage must not have magnitude greater than 999,999V!", inst, "signalConditionDCSourceVoltage");
        }
    
        if (inst.signalConditionR1 > 999999 || inst.signalConditionR1 <= 0) {
            validation.logError("Resistance must be nonzero positive value up to 999,999Ω!", inst, "signalConditionR1");
        }
    
        if (inst.signalConditionR2 > 999999 || inst.signalConditionR2 <= 0) {
            validation.logError("Resistance must be nonzero positive value up to 999,999Ω!", inst, "signalConditionR2");
        }

        if (inst.calculatedOutputSignalConditionMax > inst.signalConditionVDDA - 0.35 && inst.calculatedOutputSignalConditionMax < inst.signalConditionVDDA) {
            validation.logWarning("Maximum voltage extends outside linear range of PGA.", inst, "calculatedOutputSignalConditionMax");
        }

        if (inst.calculatedOutputSignalConditionMin < inst.signalConditionVSSA + 0.35 && inst.calculatedOutputSignalConditionMin > inst.signalConditionVSSA) {
            validation.logWarning("Minimum voltage extends outside linear range of PGA.", inst, "calculatedOutputSignalConditionMin");
        }

        if (inst.calculatedOutputSignalConditionMax > inst.signalConditionVDDA) {
            validation.logError("Maximum voltage exceeds VDDA!", inst, "calculatedOutputSignalConditionMax");
        }

        if (inst.calculatedOutputSignalConditionMin < inst.signalConditionVSSA) {
            validation.logError("Minimum voltage is less than VSSA!", inst, "calculatedOutputSignalConditionMin");
        }
    }
    
    //Filtering conditions
    if (inst.enableFilter) {
        if (inst.gainMode == device_driverlib_peripheral.PGA_GainValue[2].name
            && inst.filterMode == device_driverlib_peripheral.PGA_LowPassResistorValue[6].name)
        {
            validation.logError("Minimum resistance value for 12x gain mode is 80Ω!", inst, "filterMode");
        }
    
        if (inst.gainMode == device_driverlib_peripheral.PGA_GainValue[3].name
            && (inst.filterMode == device_driverlib_peripheral.PGA_LowPassResistorValue[5].name 
                || inst.filterMode == device_driverlib_peripheral.PGA_LowPassResistorValue[6].name))
        {
            validation.logError("Minimum resistance value for 24x gain mode is 100Ω!", inst, "filterMode");
        }

        //Cutoff Freq calculator conditions
        if (inst.useCutoffFreqCalculator) {
            if (inst.filterCapacitance > 999999 || inst.filterCapacitance <= 0 ) {
                validation.logError("Capacitance must be nonzero positive value up to 999,999pF!", inst, "filterCapacitance");
            }
        }
    }

    

    //Pin out conditions
    if (inst.PGA_INPinInfo == Pinmux.NO_DEVICE_PIN_FOUND) {
        validation.logError("Selected PGA instance not available on current device package!", inst, "pgaBase");
    }
}

function filterHardware(component)
{
    return (Common.typeMatches(component.type, ["PGA"]));
}
 
var pgaModule = {
    peripheralName: "PGA",
    displayName: "PGA",
    maxInstances: 7,
    defaultInstanceName: "myPGA",
    description: "PGA Peripheral",
    filterHardware : filterHardware,
    config: config,
    templates: {
        boardc : "/driverlib/pga/pga.board.c.xdt",
        boardh : "/driverlib/pga/pga.board.h.xdt"
    },
    validate  :  onValidate
};

if (pgaModule.maxInstances <= 0)
{
    delete pgaModule.pinmuxRequirements;
}
 
exports = pgaModule;